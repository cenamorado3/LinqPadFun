//This script creates a C# anonymous object with JSON serialization in mind, while deserializing the "return" object as a deep clone as Dictionary<string, Dictionary<string, object>>
//It needs refinement, though this should provide a lightweight solution similar to Pythons loads and dumps functions, which I do not currently know of a way to natively do in C#

void Main()
{
	var anon = new object[]{
		new {
			that = "is", 
			json = new string[]{"this", "is", "an", "array", "of", "objects"},
			numbers = new int[]{1,2,3,4,5},
			idk1 = new idk("random", 4)
		},
		new {
			str = "is", 
			strarr = new string[]{"this", "is", "an", "array", "of", "objects"},
			intarr = new int[]{1,2,3,4,5},
			idk2 = new idk("asdf", 4)
		}
	};
	Dictionary<string, Dictionary<string, object>> d = new();
	for(int i = 0;anon.Length > i; i+=1)
	{
		string payload = JsonSerializer.Serialize(anon[i]);
		using (JsonDocument document = JsonDocument.Parse(payload))
		{
		    JsonElement root = document.RootElement;
			d.Add(i.ToString(), GetChildElement(root.EnumerateObject(), i.ToString()).First()) ;
		}
	}
	d.Dump();
}


private IEnumerable<Dictionary<string, object>> GetChildElement(IEnumerable ele, string key = null)
{
	Dictionary<string, object> child = new();
	IEnumerator itter = ele.GetEnumerator();
	while(itter.MoveNext())
	{
		if(itter.Current is JsonProperty)
		{
		
			JsonValueKind jprop = ((JsonProperty)itter.Current).Value.ValueKind;
			switch(jprop)
			{
				case JsonValueKind.Object:
					//GetChildElement(((JsonProperty)itter.Current).Value.EnumerateObject(), ((JsonProperty)itter.Current).Name.ToString());
					
					//the below is handling recursion edge case, consolidate later...
					string payload = JsonSerializer.Serialize(((JsonProperty)itter.Current).Value);
					Dictionary<string, object> o = ParseDoc(payload, ((JsonProperty)itter.Current).Name).First();
					//have to merge here....
					foreach(var k in o.Keys)
					{
						if(!child.ContainsKey(((JsonProperty)itter.Current).Name))
						{
							child.Add(((JsonProperty)itter.Current).Name, o);
						}
						if(child.ContainsKey(key))
						{
							((Dictionary<string, object>)child[k]).Add(((JsonProperty)itter.Current).Name,o);
						}
					}
					
				break;
				case JsonValueKind.String:
					child.Add(((JsonProperty)itter.Current).Name, ((JsonProperty)itter.Current).Value.ToString());
				break;
				case JsonValueKind.Number:
					if (!child.ContainsKey(key))
					{
						child.Add(((JsonProperty)itter.Current).Name, ((JsonProperty)itter.Current).Value.ToString());
					}
					
					else if (child.ContainsKey(key))
					{
						child[key] += ((JsonProperty)itter.Current).Value.ToString();
					}
				break;
				case JsonValueKind.Array:
					child.Add(((JsonProperty)itter.Current).Name, new string[] {((JsonProperty)itter.Current).Value.ToString()}); //perform safe cast via EnumerateArray ?
				break;
				default:
					((JsonProperty)itter.Current).Value.Dump(">>>>>>>>>>>>>>>>>>>UNDEFINED<<<<<<<<<<<<<<");
					child.Add(((JsonProperty)itter.Current).Name, JsonValueKind.Undefined);
				break;
			}
		}
	}
	
	//if(key is not null)
	//{
	//	d.Add(key, child);
	//}
	yield return child;
}
// You can define other methods, fields, classes and namespaces here
public record idk
(
	string random,
	int t
);


IEnumerable<Dictionary<string, object>> ParseDoc(string payload, string key = "0")
{
	using (JsonDocument document = JsonDocument.Parse(payload))
	{
		Dictionary<string, Dictionary<string, object>> d = new();
	    JsonElement root = document.RootElement;
		yield return GetChildElement(root.EnumerateObject(), key).First();
	}
}
